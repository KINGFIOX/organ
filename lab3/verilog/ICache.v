// Generated by CIRCT firtool-1.62.0
// external module blk_mem_gen_1

`timescale 1ns / 1ps

`ifdef ENABLE_ICACHE    /******** 不要修改此行代码 ********/

module ICache(
  input          cpu_clk,
                 cpu_rst,
                 inst_rreq,
  input  [31:0]  inst_addr,
  output         inst_valid,
  output [31:0]  inst_out,
  output [3:0]   mem_ren,
  output [31:0]  mem_raddr,
  input  [127:0] mem_rdata,
  input          mem_rrdy,
                 mem_rvalid
);

  wire [127:0]     _dataSram_douta;
  wire [127:0]     _tagSram_douta;
  reg  [1:0]       state;
  reg  [1:0]       hit_REG;
  reg  [1:0]       hit_REG_1;
  reg  [1:0]       hit_REG_2;
  wire             _GEN = state == 2'h1;
  wire             _GEN_0 = _tagSram_douta[24:0] == {1'h1, inst_addr[31:8]};
  wire [3:0][31:0] _GEN_1 = {{_dataSram_douta[127:96]}, {_dataSram_douta[95:64]}, {_dataSram_douta[63:32]}, {_dataSram_douta[31:0]}};
  wire             _GEN_2 = state == 2'h2;
  wire             _GEN_3 = mem_rvalid & mem_rrdy;
  wire             _GEN_4 = ~(~(|state) | _GEN) & _GEN_2 & _GEN_3;
  always @(posedge cpu_clk) begin
    if (cpu_rst) state <= 2'h0;
    else if (|state) begin
      if (_GEN) state <= {~_GEN_0, 1'h0};
      else if (_GEN_2 & _GEN_3) state <= 2'h1;
    end
    else if (inst_rreq) state <= 2'h1;
    hit_REG <= state;
    hit_REG_1 <= state;
    hit_REG_2 <= hit_REG_1;
  end // always @(posedge)
  blk_mem_gen_1 tagSram (
    .clka  (cpu_clk),
    .wea   (_GEN_4),
    .addra (inst_addr[7:2]),
    .dina  ({104'h1, inst_addr[31:8]}),
    .douta (_tagSram_douta)
  );
  blk_mem_gen_1 dataSram (
    .clka  (cpu_clk),
    .wea   (_GEN_4),
    .addra (inst_addr[7:2]),
    .dina  (mem_rdata),
    .douta (_dataSram_douta)
  );
  assign inst_valid = (|state) & _GEN & _GEN_0;
  assign inst_out = _GEN_1[inst_addr[1:0]];
  assign mem_ren = ~(|state) | ~_GEN | _GEN_0 ? 4'h0 : 4'hF;
  assign mem_raddr = inst_addr;
  wire hit = ~(|state) & hit_REG == 2'h1 & hit_REG_2 != 2'h2;
endmodule

`else

module ICache(
    input  wire         cpu_clk,
    input  wire         cpu_rst,        // high active
    // Interface to CPU
    input  wire         inst_rreq,      // 来自CPU的取指请求
    input  wire [31:0]  inst_addr,      // 来自CPU的取指地址
    output reg          inst_valid,     // 输出给CPU的指令有效信号（读指令命中）
    output reg  [31:0]  inst_out,       // 输出给CPU的指令
    // Interface to Read Bus
    output reg  [ 3:0]  mem_ren,        // 输出给主存的读使能信号
    output reg  [31:0]  mem_raddr,      // 输出给主存的读地址
    input  wire [`BLK_SIZE-1:0] mem_rdata,   // 来自主存的读数据
    // 握手
    input  wire         mem_rrdy,       // 主存就绪信号（高电平表示主存可接收ICache的读请求）
    input  wire         mem_rvalid     // 来自主存的数据有效信号
);

    localparam IDLE  = 2'b00;
    localparam STAT0 = 2'b01;
    localparam STAT1 = 2'b11;
    reg [1:0] state, nstat;

    always @(posedge cpu_clk or posedge cpu_rst) begin
        state <= cpu_rst ? IDLE : nstat;
    end

    always @(*) begin
        case (state)
            IDLE:    nstat = inst_rreq ? (mem_rrdy ? STAT1 : STAT0) : IDLE;
            STAT0:   nstat = mem_rrdy ? STAT1 : STAT0;
            STAT1:   nstat = mem_rvalid ? IDLE : STAT1;
            default: nstat = IDLE;
        endcase
    end

    always @(posedge cpu_clk or posedge cpu_rst) begin
        if (cpu_rst) begin
            inst_valid <= 1'b0;
            mem_ren    <= 4'h0;
        end else begin
            case (state)
                IDLE: begin
                    inst_valid <= 1'b0;
                    mem_ren    <= (inst_rreq & mem_rrdy) ? 4'hF : 4'h0;
                    mem_raddr  <= inst_rreq ? inst_addr : 32'h0;
                end
                STAT0: begin
                    mem_ren    <= mem_rrdy ? 4'hF : 4'h0;
                end
                STAT1: begin
                    mem_ren    <= 4'h0;
                    inst_valid <= mem_rvalid ? 1'b1 : 1'b0;
                    inst_out   <= mem_rvalid ? mem_rdata[31:0] : 32'h0;
                end
                default: begin
                    inst_valid <= 1'b0;
                    mem_ren    <= 4'h0;
                end
            endcase
        end
    end


endmodule


`endif
