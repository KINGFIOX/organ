// Generated by CIRCT firtool-1.62.0
// VCS coverage exclude_file
module mem_1024x21(
  input  [9:0]  R0_addr,
  input         R0_en,
                R0_clk,
  output [20:0] R0_data,
  input  [9:0]  W0_addr,
  input         W0_en,
                W0_clk,
  input  [20:0] W0_data
);

  reg [20:0] Memory[0:1023];
  reg        _R0_en_d0;
  reg [9:0]  _R0_addr_d0;
  always @(posedge R0_clk) begin
    _R0_en_d0 <= R0_en;
    _R0_addr_d0 <= R0_addr;
  end // always @(posedge)
  always @(posedge W0_clk) begin
    if (W0_en & 1'h1)
      Memory[W0_addr] <= W0_data;
  end // always @(posedge)
  assign R0_data = _R0_en_d0 ? Memory[_R0_addr_d0] : 21'bx;
endmodule

module SRAM(
  input         clock,
                io_wea,
  input  [9:0]  io_addra,
  input  [20:0] io_dina,
  output [20:0] io_douta
);

  mem_1024x21 mem_ext (
    .R0_addr (io_addra),
    .R0_en   (1'h1),
    .R0_clk  (clock),
    .R0_data (io_douta),
    .W0_addr (io_addra),
    .W0_en   (io_wea),
    .W0_clk  (clock),
    .W0_data (io_dina)
  );
endmodule

// VCS coverage exclude_file
module mem_1024x128(
  input  [9:0]   R0_addr,
  input          R0_en,
                 R0_clk,
  output [127:0] R0_data,
  input  [9:0]   W0_addr,
  input          W0_en,
                 W0_clk,
  input  [127:0] W0_data
);

  reg [127:0] Memory[0:1023];
  reg         _R0_en_d0;
  reg [9:0]   _R0_addr_d0;
  always @(posedge R0_clk) begin
    _R0_en_d0 <= R0_en;
    _R0_addr_d0 <= R0_addr;
  end // always @(posedge)
  always @(posedge W0_clk) begin
    if (W0_en & 1'h1)
      Memory[W0_addr] <= W0_data;
  end // always @(posedge)
  assign R0_data = _R0_en_d0 ? Memory[_R0_addr_d0] : 128'bx;
endmodule

module SRAM_1(
  input          clock,
                 io_wea,
  input  [9:0]   io_addra,
  input  [127:0] io_dina,
  output [127:0] io_douta
);

  mem_1024x128 mem_ext (
    .R0_addr (io_addra),
    .R0_en   (1'h1),
    .R0_clk  (clock),
    .R0_data (io_douta),
    .W0_addr (io_addra),
    .W0_en   (io_wea),
    .W0_clk  (clock),
    .W0_data (io_dina)
  );
endmodule

module ICache(
  input          clock,
                 reset,
                 io_inst_rreq,
  input  [31:0]  io_inst_addr,
  output         io_inst_valid,
  output [31:0]  io_inst_out,
  output [3:0]   io_mem_ren,
  output [31:0]  io_mem_raddr,
  input  [127:0] io_mem_rdata,
  input          io_mem_rrdy,
                 io_mem_rvalid
);

  wire [127:0]     _dataSram_io_douta;
  wire [20:0]      _tagSram_io_douta;
  reg  [1:0]       state;
  wire             _GEN = state == 2'h0;
  wire             _GEN_0 = state == 2'h1;
  wire             _GEN_1 =
    _tagSram_io_douta == {1'h0, io_inst_addr[31:12]} & _tagSram_io_douta[20];
  wire [3:0][31:0] _GEN_2 =
    {{_dataSram_io_douta[127:96]},
     {_dataSram_io_douta[95:64]},
     {_dataSram_io_douta[63:32]},
     {_dataSram_io_douta[31:0]}};
  wire             _GEN_3 = state == 2'h2;
  wire             _GEN_4 = io_mem_rvalid & io_mem_rrdy;
  wire             _GEN_5 = ~(_GEN | _GEN_0) & _GEN_3 & _GEN_4;
  always @(posedge clock) begin
    if (reset)
      state <= 2'h0;
    else if (_GEN) begin
      if (io_inst_rreq)
        state <= 2'h1;
    end
    else if (_GEN_0)
      state <= {~_GEN_1, 1'h0};
    else if (_GEN_3 & _GEN_4 | io_inst_rreq)
      state <= 2'h1;
  end // always @(posedge)
  SRAM tagSram (
    .clock    (clock),
    .io_wea   (_GEN_5),
    .io_addra (io_inst_addr[11:2]),
    .io_dina  ({1'h1, io_inst_addr[31:12]}),
    .io_douta (_tagSram_io_douta)
  );
  SRAM_1 dataSram (
    .clock    (clock),
    .io_wea   (_GEN_5),
    .io_addra (io_inst_addr[11:2]),
    .io_dina  (io_mem_rdata),
    .io_douta (_dataSram_io_douta)
  );
  assign io_inst_valid = ~_GEN & _GEN_0 & _GEN_1;
  assign io_inst_out = _GEN_2[io_inst_addr[1:0]];
  assign io_mem_ren = _GEN | ~_GEN_0 | _GEN_1 ? 4'h0 : 4'hF;
  assign io_mem_raddr = io_inst_addr;
endmodule

