// Generated by CIRCT firtool-1.62.0
// Standard header to adapt well known macros for prints and assertions.

// Users can define 'PRINTF_COND' to add an extra gate to prints.
`ifndef PRINTF_COND_
  `ifdef PRINTF_COND
    `define PRINTF_COND_ (`PRINTF_COND)
  `else  // PRINTF_COND
    `define PRINTF_COND_ 1
  `endif // PRINTF_COND
`endif // not def PRINTF_COND_

module Divider(
  input        clock,
               reset,
  input  [8:0] io_x,
               io_y,
  input        io_start,
  output [8:0] io_z,
  output [7:0] io_r,
  output       io_busy
);

  reg [7:0]  quotient;
  reg        quotient_sign;
  reg [15:0] remain;
  reg [2:0]  cnt_value;
  reg [15:0] extend_y;
  reg        busy;
  reg        state;
  `ifndef SYNTHESIS
    always @(posedge clock) begin
      if ((`PRINTF_COND_) & ~reset) begin
        $fwrite(32'h80000002, "---------- cnt=%d ----------\n", cnt_value);
        $fwrite(32'h80000002, "remain: %b\n", remain);
        $fwrite(32'h80000002, "quotient: %b\n", quotient);
      end
    end // always @(posedge)
  `endif // not def SYNTHESIS
  always @(posedge clock) begin
    automatic logic _GEN;
    _GEN = ~state & io_start;
    if (reset) begin
      quotient <= 8'h0;
      remain <= 16'h0;
      cnt_value <= 3'h0;
      extend_y <= 16'h0;
      busy <= 1'h0;
      state <= 1'h0;
    end
    else begin
      if (state) begin
        automatic logic [15:0] _GEN_0 = {remain[14:0], 1'h0};
        automatic logic [15:0] _wire_cal_T_2;
        automatic logic [15:0] _wire_cal_T_4;
        _wire_cal_T_2 = _GEN_0 + extend_y;
        _wire_cal_T_4 = _GEN_0 - extend_y;
        if (~state | (&cnt_value)) begin
        end
        else
          quotient <=
            {quotient[6:0], ~(remain[15] ? _wire_cal_T_2[15] : _wire_cal_T_4[15])};
        if (&cnt_value) begin
          if (remain[15])
            remain <= remain + extend_y;
          else
            remain <= remain - extend_y;
        end
        else if (remain[15])
          remain <= _wire_cal_T_2;
        else
          remain <= _wire_cal_T_4;
        cnt_value <= cnt_value + 3'h1;
        state <= ~(&cnt_value);
      end
      else begin
        if (io_start) begin
          automatic logic [15:0] _wire_cal_T =
            {8'h0, io_x[7:0]} - {1'h0, io_y[7:0], 7'h0};
          quotient <= {7'h0, ~(_wire_cal_T[15])};
          remain <= _wire_cal_T;
        end
        state <= io_start | state;
      end
      if (_GEN)
        extend_y <= {1'h0, io_y[7:0], 7'h0};
      busy <= state & (state ? ~(&cnt_value) : busy);
    end
    if (_GEN)
      quotient_sign <= io_x[8] ^ io_y[8];
  end // always @(posedge)
  assign io_z = {quotient_sign, quotient};
  assign io_r = remain[14:7];
  assign io_busy = busy;
endmodule

